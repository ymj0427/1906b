2020.6.19日报
    事务的介绍:
        当你需要一次执行多条SQL语句时，可以使用事务。通俗一点说，如果这几条SQL语句全部执行成功，则才对数据库进行一次更新，
        如果有一条SQL语句执行失败，则这几条SQL语句全部不进行执行，这个时候需要用到事务。

        本地事务：
            在计算机系统中，更多的是通过关系型数据库来控制事务，这是利用数据库本身的事务特性来实现的，因此叫数据库事务，
            由于应用主要靠关系数据库来控制事务，而数据库通常和应用在同一个服务器，所以基于关系型数据库的事务又被称为本地事务。

        jdbc中使用事物：
             1.获取对数据库的连接
             2.设置事务不自动提交（默认情况是自动提交的）
    分布式事务：
        分布式系统会把一个应用系统拆分为可独立部署的多个服务，因此需要服务与服务之间远程协作才能完成事务操作，
        这种分布式系统环境下由不同的服务之间通过网络远程协作完成事务称之为分布式事务，例如用户注册送积分事务、
        创建订单减库存事务，银行转账事务等都是分布式事务。

    分布式事物产生的场景：
        1、典型的场景就是微服务架构 微服务之间通过远程调用完成事务操作。 比如：订单微服务和库存微服务，
            下单的同时订单微服务请求库存微服务减库存。简言之：跨JVM进程产生分布式事务。

        2、单体系统访问多个数据库实例 当单体系统需要访问多个数据库（实例）时就会产生分布式事务。
                比如：用户信息和订单信息分别在两个MySQL实例存储，用户管理系统删除用户信息，
                需要分别删除用户信息及用户的订单信息，由于数据分布在不同的数据实例，需要通过不同的数据库链接去操作数据，
                此时产生分布式事务。 简言之：跨数据库实例产生分布式事务。

        3、多服务访问同一个数据库实例 比如：订单微服务和库存微服务即使访问同一个数据库也会产生分布式事务，
           两个微服务持有了不同的数据库链接进行数据库操作，此时产生分布式事务。简言之：跨JVM进程产生分布式事务。

    RabbitMQ可靠消息最终一致性介绍：
        在实际系统的开发过程中，可能服务间的调用是异步的。也就是说，一个服务发送一个消息给 MQ，
        即消息中间件，比如RocketMQ、RabbitMQ、Kafka、ActiveMQ 等等。然后，另外一个服务从 MQ 消费到一条消息后进行处理。这就成了基于 MQ 的异步调用了。

        那么针对这种基于 MQ 的异步调用，如何保证各个服务间的分布式事务呢？也就是说，我希望的是基于MQ 实现异步调用的多个服务的业务逻辑，
        要么一起成功，要么一起失败。这个时候，就要用上可靠消息最终一致性方案，来实现分布式事务。

    什么是可靠消息最终一致性：
        在实际系统的开发过程中，可能服务间的调用是异步的。也就是说，一个服务发送一个消息给 MQ，即消息中间件，比如RocketMQ、RabbitMQ、Kafka、ActiveMQ 等等。

        然后，另外一个服务从 MQ 消费到一条消息后进行处理。这就成了基于 MQ 的异步调用了。

        那么针对这种基于 MQ 的异步调用，如何保证各个服务间的分布式事务呢？也就是说，我希望的是基于MQ 实现异步调用的多个服务的业务逻辑，
        要么一起成功，要么一起失败。这个时候，就要用上可靠消息最终一致性方案，来实现分布式事务。

    可靠消息最终一致性要解决的问题：
        上游服务把信息成功发送：
            本地事务与消息发送的原子性问题：事务发起方在本地事务执行成功后消息必须发出去，否则就回滚事务。即实现本地事务和消息发送的原子性，要么都成功，要么都失败。

        下游服务成把消息成功消费：
            事务参与方接收消息的可靠性：事务参与方必须能够从消息队列接收到消息。

        对消息做幂：
            消息重复消费的问题：由于网络2的存在，若某一个消费节点响应超时但是消费成功，此时消息中间件会重复投递此消息，就导致了消息的重复消费。

        问题一：上游服务把消息成功发送：
            针对问题一可采用消息表这个方案，该方案最初是eBay提出的，此方案的核心是：在系统A处理任务完成后，
            在本地记录待发送信息。一个定时任务不断检查，是否发送成功，如果发送成功，将记录状态修改。
        问题二：下游服务成把消息成功消费：
            消息重试：消息持久化后，如果消息在投递过程中丢失，或消息的确认应答在返回途中丢失，那么消息中间件就会重新投递，直到下游消费者返回消费成功响应为止。
            任务失败：当任务处理失败后，则返回给消息中间件失败，消息会重复发送
        问题三：对消息做幂等：
            任务B处理消息前，先查询该消息是否被消费，如果没消费，处理任务B成功，记录消息。如果消息已经被消费，直接返回应答成功